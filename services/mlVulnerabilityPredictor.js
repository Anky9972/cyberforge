/**
 * ML Vulnerability Predictor Service
 * Uses TensorFlow.js to predict vulnerability likelihood
 */
import * as tf from '@tensorflow/tfjs-node';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
class MLVulnerabilityPredictor {
    model = null;
    isModelLoaded = false;
    MODEL_PATH = './models/vulnerability-predictor';
    constructor() {
        this.initializeModel();
    }
    /**
     * Initialize or load the model
     */
    async initializeModel() {
        try {
            // Try to load existing model
            this.model = await tf.loadLayersModel(`file://${this.MODEL_PATH}/model.json`);
            this.isModelLoaded = true;
            console.log('âœ… ML Vulnerability Predictor model loaded');
        }
        catch (error) {
            // Model doesn't exist yet, will create on first train
            console.log('â„¹ï¸  No existing model found. Will create on first training.');
        }
    }
    /**
     * Extract features from code
     */
    extractFeatures(code) {
        const features = {
            complexity: 0,
            linesOfCode: code.split('\n').length,
            functionCount: 0,
            dangerousFunctions: 0,
            externalImports: 0,
            conditionals: 0,
            loops: 0,
            tryBlocks: 0,
            evalUsage: 0,
            sqlPatterns: 0,
            commandExecution: 0,
            fileOperations: 0
        };
        try {
            const ast = parse(code, {
                sourceType: 'module',
                errorRecovery: true
            });
            traverse(ast, {
                FunctionDeclaration: () => features.functionCount++,
                ArrowFunctionExpression: () => features.functionCount++,
                FunctionExpression: () => features.functionCount++,
                IfStatement: () => {
                    features.conditionals++;
                    features.complexity++;
                },
                WhileStatement: () => {
                    features.loops++;
                    features.complexity += 2;
                },
                ForStatement: () => {
                    features.loops++;
                    features.complexity += 2;
                },
                TryStatement: () => features.tryBlocks++,
                ImportDeclaration: () => features.externalImports++,
                CallExpression: (path) => {
                    const callee = path.node.callee;
                    if (callee.type === 'Identifier') {
                        const name = callee.name;
                        // Dangerous functions
                        if (['eval', 'Function'].includes(name)) {
                            features.evalUsage++;
                            features.dangerousFunctions++;
                        }
                        // Command execution
                        if (['exec', 'spawn', 'execFile', 'system'].includes(name)) {
                            features.commandExecution++;
                            features.dangerousFunctions++;
                        }
                        // File operations
                        if (['readFile', 'writeFile', 'unlink', 'rmdir'].includes(name)) {
                            features.fileOperations++;
                        }
                    }
                    if (callee.type === 'MemberExpression' && callee.property.type === 'Identifier') {
                        const propName = callee.property.name;
                        if (['query', 'execute', 'run'].includes(propName)) {
                            features.sqlPatterns++;
                        }
                    }
                }
            });
        }
        catch (error) {
            console.error('Error extracting features:', error);
        }
        return features;
    }
    /**
     * Convert features to tensor
     */
    featuresToTensor(features) {
        const featureArray = [
            features.complexity / 100, // Normalize
            features.linesOfCode / 1000,
            features.functionCount / 50,
            features.dangerousFunctions / 10,
            features.externalImports / 20,
            features.conditionals / 50,
            features.loops / 20,
            features.tryBlocks / 10,
            features.evalUsage,
            features.sqlPatterns,
            features.commandExecution,
            features.fileOperations / 10
        ];
        return tf.tensor2d([featureArray]);
    }
    /**
     * Train the model with historical data
     */
    async train(trainingData) {
        console.log(`ðŸŽ“ Training ML model with ${trainingData.length} samples...`);
        const features = trainingData.map(d => this.extractFeatures(d.code));
        const labels = trainingData.map(d => d.hasVulnerability ? 1 : 0);
        const featureArrays = features.map(f => [
            f.complexity / 100,
            f.linesOfCode / 1000,
            f.functionCount / 50,
            f.dangerousFunctions / 10,
            f.externalImports / 20,
            f.conditionals / 50,
            f.loops / 20,
            f.tryBlocks / 10,
            f.evalUsage,
            f.sqlPatterns,
            f.commandExecution,
            f.fileOperations / 10
        ]);
        const xTrain = tf.tensor2d(featureArrays);
        const yTrain = tf.tensor1d(labels);
        // Create model if it doesn't exist
        if (!this.model) {
            this.model = tf.sequential({
                layers: [
                    tf.layers.dense({
                        units: 128,
                        activation: 'relu',
                        inputShape: [12],
                        kernelInitializer: 'heNormal'
                    }),
                    tf.layers.dropout({ rate: 0.3 }),
                    tf.layers.dense({
                        units: 64,
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({
                        units: 32,
                        activation: 'relu'
                    }),
                    tf.layers.dense({
                        units: 1,
                        activation: 'sigmoid'
                    })
                ]
            });
            this.model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
        }
        // Train the model
        await this.model.fit(xTrain, yTrain, {
            epochs: 50,
            batchSize: 32,
            validationSplit: 0.2,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    if (epoch % 10 === 0) {
                        console.log(`Epoch ${epoch}: loss=${logs?.loss.toFixed(4)}, acc=${logs?.acc.toFixed(4)}`);
                    }
                }
            }
        });
        // Save the model
        await this.model.save(`file://${this.MODEL_PATH}`);
        this.isModelLoaded = true;
        console.log('âœ… Model trained and saved successfully');
        // Cleanup tensors
        xTrain.dispose();
        yTrain.dispose();
    }
    /**
     * Predict vulnerability for code
     */
    async predict(code) {
        if (!this.model) {
            // Return heuristic-based prediction if model not loaded
            return this.heuristicPrediction(code);
        }
        try {
            const features = this.extractFeatures(code);
            const tensor = this.featuresToTensor(features);
            const prediction = this.model.predict(tensor);
            const score = (await prediction.data())[0];
            tensor.dispose();
            prediction.dispose();
            const riskLevel = this.getRiskLevel(score);
            const suggestedActions = this.getSuggestedActions(features, score);
            return {
                vulnerabilityScore: score,
                confidence: this.calculateConfidence(features),
                riskLevel,
                suggestedActions
            };
        }
        catch (error) {
            console.error('Error predicting vulnerability:', error);
            return this.heuristicPrediction(code);
        }
    }
    /**
     * Heuristic-based prediction (fallback)
     */
    heuristicPrediction(code) {
        const features = this.extractFeatures(code);
        let score = 0;
        score += features.evalUsage * 0.3;
        score += features.commandExecution * 0.25;
        score += features.dangerousFunctions * 0.2;
        score += features.sqlPatterns * 0.15;
        score += (features.complexity / 100) * 0.1;
        score = Math.min(score, 1);
        return {
            vulnerabilityScore: score,
            confidence: 0.6, // Lower confidence for heuristic
            riskLevel: this.getRiskLevel(score),
            suggestedActions: this.getSuggestedActions(features, score)
        };
    }
    /**
     * Get risk level from score
     */
    getRiskLevel(score) {
        if (score >= 0.75)
            return 'critical';
        if (score >= 0.5)
            return 'high';
        if (score >= 0.25)
            return 'medium';
        return 'low';
    }
    /**
     * Calculate confidence based on features
     */
    calculateConfidence(features) {
        // More code and features = higher confidence
        let confidence = 0.5;
        if (features.linesOfCode > 100)
            confidence += 0.1;
        if (features.functionCount > 5)
            confidence += 0.1;
        if (features.tryBlocks > 0)
            confidence += 0.1;
        return Math.min(confidence, 1);
    }
    /**
     * Get suggested actions based on features
     */
    getSuggestedActions(features, score) {
        const actions = [];
        if (features.evalUsage > 0) {
            actions.push('Remove or secure eval() usage with proper input validation');
        }
        if (features.commandExecution > 0) {
            actions.push('Sanitize command execution inputs and use parameterized commands');
        }
        if (features.sqlPatterns > 0) {
            actions.push('Use prepared statements to prevent SQL injection');
        }
        if (features.complexity > 50) {
            actions.push('Reduce code complexity by refactoring into smaller functions');
        }
        if (features.tryBlocks === 0 && features.functionCount > 0) {
            actions.push('Add error handling with try-catch blocks');
        }
        if (score > 0.5 && actions.length === 0) {
            actions.push('Review code for potential security vulnerabilities');
            actions.push('Run static analysis tools');
            actions.push('Implement input validation');
        }
        return actions;
    }
    /**
     * Batch predict multiple files
     */
    async batchPredict(codes) {
        const results = [];
        for (const code of codes) {
            const result = await this.predict(code);
            results.push(result);
        }
        return results;
    }
}
export const mlVulnerabilityPredictor = new MLVulnerabilityPredictor();
export default MLVulnerabilityPredictor;
//# sourceMappingURL=mlVulnerabilityPredictor.js.map